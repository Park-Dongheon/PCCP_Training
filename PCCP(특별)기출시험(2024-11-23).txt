문제 설명:
당신은 화살표 방향을 맞추는 게임을 합니다. 위 또는 아래를 가리키는 화살표가 하나씩 입력됩니다. 입력된 화살표와 당신의 화살표 방향이 같다면 통과하지만 다르다면 연속해서 방향을 틀린 횟수만큼 벌점을 받습니다. 당신의 화살표는 게임을 시작할 때 위를 가리키고 있습니다. 원하는 타이밍에 버튼을 눌러 당신이 가진 화살표의 방향을 딱 한 번만 바꿀 수 있으며, 버튼을 누르지 않을 수도 있습니다.
	↑↑↓↓↓↑
  You →	↑↑↑↑↑↑
- 왼쪽부터 순서대로 위, 위, 아래, 아래, 아래, 위 방향으로 화살표 6개가 입력될 때 버튼을 누르지 않으면 3, 4, 5 번째 화살표를 틀리고 받는 벌점은 1 + 2 + 3 = 6 점 입니다.
	↑↑↓↓↓↑
  You →	↑↑↓↓↓↓
- 만약 3번째 화살표가 입력될 때 버튼을 눌러 화살표의 방향을 바꾸면, 마지막 화살표 입력만 틀려 벌점을 1점 받습니다. 이보다 더 작은 벌점을 받는 방법은 없습니다. 입력될 n 개의 화살표 방향을 나타내는 1차원 정수 배열 arrows 가 매개변수로 주어집니다. 이때 벌점을 최소로 만들기 위해 몇 번째 화살표가 입력될 때 방향을 바꿔야 하는지 return 하도록 solution 함수를 완성해 주세요.
만약 화살표 방향을 바꾸지 않을 때 벌점이 최소라면 -1을, 벌점을 최소로 만드는 방법이 여러 개라면 가장 빠른 번호를 return 해주세요.

제한 사항:
- 1 <= arrows 의 길이 = n <= 100
	- arrows[i]는 i + 1 번째 화살표의 방향을 의미합니다.
	- arrows[i] 는 0 또는 1 입니다.
	- 0은 위를 가리키는 화살표를 나타냅니다.
	- 1은 아래를 가리키는 화살표를 나타냅니다.

입출력 예:
	arrows			result
	[0, 0, 1, 1, 1, 0]		3
	[0, 0, 0, 0, 0]		-1
	[0, 0, 0, 0, 1, 0, 1, 1]	5
	[1, 1, 1, 0, 0, 1, 0, 1, 0, 0]	1
	[1, 1, 1, 0, 0, 0]		-1

입출력 예 설명:
	입출력 예 #1: 문제 예시와 동일합니다.
	입출력 예 #2: 버튼을 누르지 않았을 때 벌점이 0점으로 가장 작습니다. 따라서 -1을 return 해야 합니다.
	입출력 예 #3: 5번째, 또는 7번째 화살표가 입력될 때 버튼을 누르면 벌점이 1점으로 가장 작습니다. 둘 중 더 		      빠른 5를 return 해야 합니다.
	입출력 예 #4: 첫 번째 화살표가 입력될 때 버튼을 누르면 벌점이 7점으로 가장 작습니다. 따라서 1을 return 		      해야 합니다.
	입출력 예 #5: 버튼을 누르지 않았을 때, 첫 번째 화살표가 입력될 때 버튼을 눌렀을 때 벌점이 6점으로 가장 		      작습니다. 화살표 방향을 바꾸지 않았을 때 벌점이 최소이므로 -1을 return 해야 합니다.

---------------------------------------------------------------------------------------------------------------------------------------------

문제 설명:
당신은 1 ~ n 번으로 분류되는 각기 다른 상품 n 개를 인터넷 쇼핑몰에서 주문하려 합니다. 당신은 1 ~ m 번으로 분류되는 m 개의 쇼핑몰에서 당신이 주문하려는 상품 중 어떤 상품들을 파는지 조사했습니다. 당신은 배송비를 아끼기 위해 모든 상품을 주문하면서 가능한 적은 수의 쇼핑몰만 이용하려면 어떤 쇼핑몰들을 이용해야되는지 알고 싶습니다.
예를 들어, 1 ~ 5 번의 5개의 상품을 주문해야 하고, 이 상품들을 파는 쇼핑몰이 6개 있다고 가정하겠습니다.

쇼핑몰 번호	판매상품
1번 쇼핑몰	2, 3
2번 쇼핑몰	1, 3
3번 쇼핑몰	2, 3, 4
4번 쇼핑몰	1
5번 쇼핑몰	4, 5
6번 쇼핑몰	1, 3, 4

쇼핑몰 2개 이하만 이용하면서 모든 상품을 주문하는 것은 불가능하므로 최소 3개 이상의 쇼핑몰을 이용해야 합니다. 1, 2, 5 번 쇼핑몰 3개를 이용하면 모든 상품을 주문할 수 있습니다.
	- 1번 쇼핑몰에서 2, 3 번 상품을 주문합니다.
	- 2번 쇼핑몰에서 1 번 상품을 주문합니다.
	- 5번 쇼핑몰에서 4, 5 번 상품을 주문합니다.
주문하려는 각기 다른 상품의 수를 나타내는 정수 n 과 쇼핑몰에서 판매하는 상품정보를 담은 2차원 정수 배열 shops 가 매개변수로 주어집니다.
모든 상품을 주문할 수 있는 가장 적은 수의 쇼핑몰을 이용할 때, 이용할 쇼핑몰들의 번호를 오름차순으로 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 정답이 여러 가지인 경우, 사전 순으로 가장 앞서는 답을 return 해주세요. 길이가 같은 서로 다른 두 배열 중 사전 순으로 앞서는 배열에 대한 설명은 다음과 같습니다.
	- 두 배열 중 첫 번째 수가 작은 쪽이 다른 배열보다 사전 순으로 앞섭니다.
	- 두 배열의 첫 번째 수가 같다면, 첫 번째 수를 빼고 두 배열을 다시 비교했을 때 사전 순으로 앞서는 쪽이 사전 순으로 앞		  섭니다. 두 배열의 첫 번째 수가 다를 때까지 이를 반복합니다.

제한 사항:
	- 3 <= n <= 30
	- 3 <= shops 의 길이 = m <= 16
		- shops[i] 의 길이 = n
			- shops[i][j] 는 0 또는 1 입니다.
			- shops[i][j] 가 1인 경우, i + 1 번 쇼핑몰에서 j + 1 번 상품을 판매함을 의미합니다.
			- shops[i][j] 가 0인 경우, i + 1 번 쇼핑몰에서 j + 1 번 상품을 판매하지 않음을 의미합니다.
	- 모든 쇼핑몰은 적어도 하나 이상의 상품을 판매하며, 항상 1 ~ n 까지의 상품을 모두 주문할 수 있는 경우만 주어집니다.

입출력 예:
	n	shops					result
	5	[[0, 1, 1, 0, 0], [1, 0, 1, 0, 0], [0, 1, 1, 1, 0],	[1, 2, 5]
		 [1, 0, 0, 0, 0], [0, 0, 0, 1, 1], [1, 0, 1, 1, 0]]
	4	[[1, 0, 0, 0], [1, 1, 0, 0], [1, 0, 0, 1], 		[2, 4]
		 [0, 0, 1, 1], [1, 0, 0, 0],]

입출력 예 설명:
	입출력 예 #1: 문제 예시와 동일합니다. 쇼핑몰을 3개만 이용했을 때 가능한 답은 아래와 같이 6개가 있습니다. 
			- [1, 2, 5]
			- [1, 4, 5]
			- [1, 5, 6]
			- [2, 3, 5]
			- [3, 4, 5]
			- [3, 5, 6]

			- 이 중 사전 순으로 가장 앞서는 [1, 2, 5] 를 return 하면 됩니다.
	입출력 예 #2: 쇼핑몰 번호	판매 상품
		     1번 쇼핑몰	1
		     2번 쇼핑몰	1, 2
		     3번 쇼핑몰	1, 4
		     4번 쇼핑몰	3, 4
		     5번 쇼핑몰	1

		     쇼핑몰 1개 이하만 이용하면서 모든 상품을 주문하는 것은 불가능 하므로 최소 2개 이상의 쇼핑몰을 이용해		     	     야 합니다. 2, 4 번 쇼핑몰을 이용하는 경우가 쇼핑몰을 2개 이용하는 유일한 답입니다.
			- 2번 쇼핑몰에서 1, 2 번 상품을 주문합니다.
			- 4번 쇼핑몰에서 3, 4 번 상품을 주문합니다.
		     따라서 [2, 4] 를 return 하면 됩니다.

---------------------------------------------------------------------------------------------------------------------------------------------

문제 설명:
전사들의 섬에서 n 명의 전사들이 살고 있습니다. 이 전사들은 아래와 같은 규칙으로 다른 전사들에게 전투를 신청합니다.
	- 각 전사들마다 전투 신청의 날 이 정해져 있습니다.
	- 전투 신청의 날 이 주말(토요일 혹은 일요일)인 전사는 전투를 신청하지 않습니다.
	- 전투 신청의 날이 주말이 아닌 전산는 다음과 같은 방법으로 전투를 신청합니다.
		- 올해 기준 상대의 전투 신청의 날 이 자신과 5일 이상 차이나는 모든 전사에게 전투를 신청합니다. 전투 신청		  의 날 이 각각 1월 1일, 12월 31일인 전사의 경우 올해 기준 전투 신청의 날 의 차이는 364 일 입니다.
당신은 올 한 해동안 전투 신청이 총 몇 번 이루어지는지 구하려고 합니다. 전사들의 전투 신청의 날 을 담은 1차원 문장열 배열 fights 가 주어집니다. 이때, 전사들이 올 한 해동안 전투 신청을 총 몇 번하는지 return 하도록 solution 함수를 완성해 주세요.

제한 사항:
	- 1 <= fights 의 길이 = n <= 500,000
		- fights[i]는 "MMDD" 형태의 문자열로 MM 월 DD 일이 i + 1 번째 전사의 전투 신청의 날 임을 의미합니다.
	- 1, 3, 5, 7, 8, 10, 12 월은 31 일 까지 존재합니다.
	- 2월은 28일 까지 존재합니다.
	- 4, 6, 9, 11 월은 30 일 까지 존재합니다.
	- 1월 1일은 일요일입니다.
	- 전투 신청의 날이 2월 29일인 전사는 없습니다.

입출력 예:
	fights				result
	["0101", "0103", "0110"]		3
	["0323", "0620", "0329", "0328",	28
	 "0830", "0327", "0521"]

입출력 예 설명:
	입출력 예 #1: 전투 신청은 다음과 같이 이루어 집니다.
		     전사	전투 신청
		     1	-
		     2	3
		     3	1, 2
		     	- 1번 전사는 전투 신청의 날 이 주말이기 때문에 전투 신청을 하지 않습니다.
			- 2번 전사는 전투 신청의 날 차이가 5일 이상인 3 번에게만 전투를 신청합니다.
			- 3번 전사는 전투 신청의 날 차이가 5일 이상인 1, 2 번에게만 전투를 신청합니다.
		     총 전투 신청 횟수는 3 회 입니다. 따라서 3을 return 해야 합니다.
	입출력 예 #2: 전투 신청은 다음과 같이 이루어 집니다.
		     전사	전투 신청
		     1	2, 3, 4, 5, 7
		     2	1, 3, 4, 5, 6, 7
		     3	1, 2, 5, 7
		     4	1, 2, 5, 7
		     5	1, 2, 3, 4, 6, 7
		     6	2, 5, 7
		     7	-
		     총 전투 신청 횟수는 28 회 입니다. 따라서 28을 return 해야 합니다.